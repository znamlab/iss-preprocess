import numpy as np
from skimage.draw import disk
from ..segment import ROI
from sklearn.mixture import GaussianMixture
from scipy.spatial.distance import hamming

BASES = np.array(['G','T','A','C'])


def extract_spots(spots, stack):
    """
    Create ROIs based on spot locations and extract their fluorescence traces.

    Args:
        spots (pandas.DataFrame):
        stack (numpy.ndarray): X x Y x R x C stack.

    Returns:
        List of ROI objects.

    """
    rois = []
    for _, spot in spots.iterrows():
        rr, cc = disk((spot['y'], spot['x']), spot['size'], shape=stack.shape[0:2])
        roi = ROI(xpix=rr, ypix=cc, shape=stack.shape[0:2])
        roi.trace = stack[roi.xpix,roi.ypix,:,:].mean(axis=0)
        rois.append(roi)

    return rois


def rois_to_array(rois, normalize=True):
    # rounds x channels x rois matrix
    x = np.stack([roi.trace for roi in rois], axis=2)
    # normalize by mean intensity
    if normalize:
        x = x / np.mean(x, axis=1)[:,np.newaxis,:]
    return x


def basecall_rois(rois, separate_rounds=True, rounds=()):
    """
    Assign bases using a Gaussian Mixture Model.

    Args:
        rois (list): list of ROI objects.
        separate_rounds (bool): whether to run basecalling separately on each
            round or on all rounds together. Default True.
        rounds: numpy.array of rounds to include.

    Returns:
        ROIs x rounds of base IDs.

    """
    def predict_bases(data_):
        gmm = GaussianMixture(n_components=4, random_state=0).fit(data_)
        # GMM components are arbitrarily ordered. We assign each component to a
        # based on its maximum channel.
        base_id = np.argmax(gmm.means_, axis=1)
        labels = gmm.predict(data_)
        return base_id[labels]

    x = rois_to_array(rois)
    if rounds:
        x = x[rounds,:,:]
    if separate_rounds:
        bases = np.empty((x.shape[2], x.shape[0]), dtype=int)
        for round in range(x.shape[0]):
            data = x[round,:,:].transpose()
            bases[:, round] = predict_bases(data)
    else:
        data = np.moveaxis(x, 0, 2).reshape((4,-1)).transpose()
        bases = predict_bases(data)
        bases = np.reshape(bases,(x.shape[2], x.shape[0]))

    return bases


def call_genes(sequences, codebook):
    """
    Assignes sequences to genes based on the provided codebook.

    Args:
        sequences (numpy.ndarray): ROIs x rounds array of base IDs generated by
            `basecall_rois`.
        codebook (pandas.DataFrame): gene codes, containing 'gii', 'seq', and 'gene'
            columns.

    Returns:
        List of most closely matching gene names.
        List of edit distances.

    """
    genes = []
    errors = []
    for s in sequences:
        seq = BASES[s]
        dist_series = codebook['seq'].apply(lambda x: hamming(list(x), seq)*len(x))
        dist = dist_series.min()
        genes.append(codebook.iloc[dist_series.argmin()]['gene'])
        errors.append(dist)
    return genes, errors
